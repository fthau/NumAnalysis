import numpy as np
import matplotlib.pyplot as plt

# Input data
time = np.array([0, 3, 5, 8, 13])
distance = np.array([0, 225, 383, 623, 993])
speed = np.array([75, 77, 80, 74, 72])

# Doubling the nodes for Hermite interpolation
z = np.repeat(time, 2)
n = len(z)
Q = np.zeros((n, n))

# Step 2: Setting initial values in the divided difference table
for i in range(len(time)):
    Q[2 * i][0] = distance[i]
    Q[2 * i + 1][0] = distance[i]
    Q[2 * i + 1][1] = speed[i]
    if i != 0:
        Q[2 * i][1] = (Q[2 * i][0] - Q[2 * i - 1][0]) / (z[2 * i] - z[2 * i - 1])

# Step 4: Filling the rest of the divided difference table
for i in range(2, n):
    for j in range(2, i + 1):
        Q[i][j] = (Q[i][j - 1] - Q[i - 1][j - 1]) / (z[i] - z[i - j])

# Displaying the divided difference table
print("Divided Difference Table (Q):")
print(Q)

# Function to evaluate the Hermite polynomial at a given x using the divided differences
def hermite_polynomial(x):
    result = Q[0, 0]
    product_term = 1
    for i in range(1, n):
        product_term *= (x - z[i - 1])
        result += Q[i, i] * product_term
    return result

# Predicting the position at t = 10
predicted_position = hermite_polynomial(10)
print(f"Predicted position at t = 10 seconds: {predicted_position:.2f} feet")

# Plotting the position of the car from t = 0 to t = 13
t_values = np.linspace(0, 13, 100)
position_values = [hermite_polynomial(t) for t in t_values]

plt.plot(t_values, position_values, label="Hermite Interpolating Polynomial")
plt.scatter(time, distance, color="red", label="Given Data Points")
plt.xlabel("Time (seconds)")
plt.ylabel("Distance (feet)")
plt.title("Position of the Car Using Hermite Interpolation")
plt.legend()
plt.grid(True)
plt.show()
